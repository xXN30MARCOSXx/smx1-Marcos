<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Bosque con minimapa y colisiones</title>
  <style>
    body { margin: 0; background: #121212; color: #ddd; font-family: system-ui, sans-serif; display:flex; }
    #hud { position: fixed; left: 10px; top: 10px; background: rgba(0,0,0,0.45); padding: 6px 10px; border-radius: 6px; font-size: 14px; backdrop-filter: blur(3px); }
    #game { background: #0c1510; image-rendering: crisp-edges; image-rendering: pixelated; }
    #rightPanel { display:flex; flex-direction:column; gap:8px; padding:8px; width: 220px; }
    #minimap { background:#1a1a1a; border:2px solid #4a4a4a; }
  </style>
</head>
<body>
  <div id="hud">Controles: WASD / Flechas. Árboles = muros. Toca el tesoro para moverlo.</div>
  <canvas id="game" width="640" height="480"></canvas>
  <div id="rightPanel">
    <canvas id="minimap" width="200" height="200"></canvas>
  </div>

  <script>
    // Parámetros
    const TILE = 32;
    const MAP_W = 40;
    const MAP_H = 40;
    const VIEW_W = 640;
    const VIEW_H = 480;

    // Canvas
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const mini = document.getElementById('minimap');
    const mctx = mini.getContext('2d');

    // Tipos y colores
    const TILE_TYPES = { GRASS: 0, TREE: 1 };
    const COLORS = {
      grassA: '#2a9d8f',
      grassB: '#238b81',
      grassC: '#1f7a72',
      treeTrunk: '#4a3428',
      treeLeaves: '#2f6d3e',
      treeShadow: '#1e4d2a',
      player: '#ffd166',
      treasure: '#e76f51'
    };

    // Mapa
    const map = new Array(MAP_W * MAP_H).fill(TILE_TYPES.GRASS);

    function randSeeded(x, y) {
      const s = Math.sin(x * 127.1 + y * 311.7) * 43758.5453123;
      return s - Math.floor(s);
    }

    function generateForest(density = 0.32) {
      for (let y = 0; y < MAP_H; y++) {
        for (let x = 0; x < MAP_W; x++) {
          const i = y * MAP_W + x;
          const n1 = randSeeded(x, y);
          const n2 = randSeeded(x * 0.61, y * 0.61);
          const noise = (n1 * 0.7 + n2 * 0.3);
          map[i] = noise < density ? TILE_TYPES.TREE : TILE_TYPES.GRASS;
        }
      }
      // senderos para jugabilidad
      for (let y = 8; y < MAP_H - 8; y += 16) {
        for (let x = 1; x < MAP_W - 1; x++) map[y * MAP_W + x] = TILE_TYPES.GRASS;
      }
      for (let x = 8; x < MAP_W - 8; x += 16) {
        for (let y = 1; y < MAP_H - 1; y++) map[y * MAP_W + x] = TILE_TYPES.GRASS;
      }
    }
    generateForest();

    // Entidades
    const player = { x: 5, y: 5, speed: 6 };
    const treasure = { x: 0, y: 0 };

    function placeInEmpty(obj) {
      let attempts = 0;
      while (attempts++ < 5000) {
        const x = Math.floor(Math.random() * MAP_W);
        const y = Math.floor(Math.random() * MAP_H);
        if (map[y * MAP_W + x] === TILE_TYPES.GRASS) {
          obj.x = x; obj.y = y; return;
        }
      }
      // Fallback secuencial
      for (let y = 0; y < MAP_H; y++) {
        for (let x = 0; x < MAP_W; x++) {
          if (map[y * MAP_W + x] === TILE_TYPES.GRASS) { obj.x = x; obj.y = y; return; }
        }
      }
    }
    placeInEmpty(treasure);

    // Entrada
    const keys = new Set();
    window.addEventListener('keydown', e => {
      const k = e.key.toLowerCase();
      if (['w','a','s','d','arrowup','arrowdown','arrowleft','arrowright'].includes(k)) {
        keys.add(k); e.preventDefault();
      }
    });
    window.addEventListener('keyup', e => keys.delete(e.key.toLowerCase()));

    // Colisiones
    function canWalk(nx, ny) {
      if (nx < 0 || ny < 0 || nx >= MAP_W || ny >= MAP_H) return false;
      return map[ny * MAP_W + nx] !== TILE_TYPES.TREE;
    }

    function movePlayer() {
  let nx = Math.floor(player.x);
  let ny = Math.floor(player.y);

  if (keys.has('w') || keys.has('arrowup')) ny -= 1;
  if (keys.has('s') || keys.has('arrowdown')) ny += 1;
  if (keys.has('a') || keys.has('arrowleft')) nx -= 1;
  if (keys.has('d') || keys.has('arrowright')) nx += 1;

  if (canWalk(nx, ny)) {
    player.x = nx;
    player.y = ny;
  }
}


    function checkTreasure() {
      if (Math.floor(player.x) === treasure.x && Math.floor(player.y) === treasure.y) {
        placeInEmpty(treasure);
      }
    }

    // Cámara
    const camera = { x: 0, y: 0, w: Math.floor(VIEW_W / TILE), h: Math.floor(VIEW_H / TILE) };
    function updateCamera() {
      camera.x = Math.floor(player.x - camera.w / 2);
      camera.y = Math.floor(player.y - camera.h / 2);
      camera.x = Math.max(0, Math.min(camera.x, MAP_W - camera.w));
      camera.y = Math.max(0, Math.min(camera.y, MAP_H - camera.h));
    }

    // Render visual mejorado
    function drawGrassTile(sx, sy, x, y) {
      const t = (x * 13 + y * 7) % 3;
      ctx.fillStyle = t === 0 ? COLORS.grassA : (t === 1 ? COLORS.grassB : COLORS.grassC);
      ctx.fillRect(sx, sy, TILE, TILE);
      // textura suave
      ctx.fillStyle = 'rgba(255,255,255,0.03)';
      ctx.fillRect(sx, sy, TILE, 1);
      ctx.fillRect(sx, sy + TILE - 2, TILE, 1);
    }

    function drawTreeTile(sx, sy) {
      // base
      ctx.fillStyle = COLORS.grassB;
      ctx.fillRect(sx, sy, TILE, TILE);
      // sombra
      ctx.fillStyle = COLORS.treeShadow;
      ctx.beginPath(); ctx.arc(sx + 8, sy + 10, 7, 0, Math.PI * 2); ctx.fill();
      // copa con degradado
      const g = ctx.createRadialGradient(sx + 8, sy + 7, 2, sx + 8, sy + 8, 7);
      g.addColorStop(0, '#3b8f54');
      g.addColorStop(1, COLORS.treeLeaves);
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(sx + 8, sy + 8, 6, 0, Math.PI * 2); ctx.fill();
      // tronco
      ctx.fillStyle = COLORS.treeTrunk;
      ctx.fillRect(sx + 6, sy + 10, 4, 6);
    }

    function drawTile(x, y, type) {
      const sx = (x - camera.x) * TILE;
      const sy = (y - camera.y) * TILE;
      if (type === TILE_TYPES.GRASS) {
        drawGrassTile(sx, sy, x, y);
      } else {
        drawTreeTile(sx, sy);
      }
    }

    let shine = 0; // brillo animado del tesoro
    function drawTreasure() {
      const sx = (treasure.x - camera.x) * TILE;
      const sy = (treasure.y - camera.y) * TILE;
      // caja
      ctx.fillStyle = COLORS.treasure;
      ctx.fillRect(sx + 3, sy + 3, TILE - 6, TILE - 6);
      // borde
      ctx.strokeStyle = '#ffb4a2';
      ctx.strokeRect(sx + 3, sy + 3, TILE - 6, TILE - 6);
      // brillo animado
      const alpha = 0.3 + 0.2 * Math.sin(shine);
      ctx.fillStyle = `rgba(255,255,255,${alpha})`;
      ctx.fillRect(sx + 4, sy + 4, TILE - 8, 2);
    }

    function drawPlayer() {
      const sx = (player.x - camera.x) * TILE;
      const sy = (player.y - camera.y) * TILE;
      ctx.fillStyle = COLORS.player;
      ctx.beginPath();
      ctx.arc(sx + TILE/2, sy + TILE/2, 6, 0, Math.PI * 2);
      ctx.fill();
      // sombra ligera
      ctx.fillStyle = 'rgba(0,0,0,0.15)';
      ctx.beginPath();
      ctx.arc(sx + TILE/2, sy + TILE/2 + 3, 5, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawScene() {
      ctx.clearRect(0, 0, VIEW_W, VIEW_H);
      const endX = Math.min(MAP_W, camera.x + camera.w + 1);
      const endY = Math.min(MAP_H, camera.y + camera.h + 1);
      for (let y = camera.y; y < endY; y++) {
        for (let x = camera.x; x < endX; x++) {
          if (x >= 0 && y >= 0 && x < MAP_W && y < MAP_H) {
            drawTile(x, y, map[y * MAP_W + x]);
          }
        }
      }
      drawTreasure();
      drawPlayer();

      // viñeteado sutil
      const grd = ctx.createLinearGradient(0, 0, 0, VIEW_H);
      grd.addColorStop(0, 'rgba(0,0,0,0.05)');
      grd.addColorStop(1, 'rgba(0,0,0,0.22)');
      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, VIEW_W, VIEW_H);
    }

    // Minimap
    function drawMinimap() {
      const scaleX = mini.width / MAP_W;
      const scaleY = mini.height / MAP_H;
      mctx.clearRect(0, 0, mini.width, mini.height);

      // fondo
      mctx.fillStyle = '#111';
      mctx.fillRect(0, 0, mini.width, mini.height);

      // terreno
      for (let y = 0; y < MAP_H; y++) {
        for (let x = 0; x < MAP_W; x++) {
          mctx.fillStyle = map[y * MAP_W + x] === TILE_TYPES.TREE ? COLORS.treeLeaves : COLORS.grassA;
          mctx.fillRect(x * scaleX, y * scaleY, scaleX, scaleY);
        }
      }

      // cámara (rectángulo de vista)
      mctx.strokeStyle = '#ffffff88';
      mctx.lineWidth = 1;
      mctx.strokeRect(camera.x * scaleX, camera.y * scaleY, camera.w * scaleX, camera.h * scaleY);

      // tesoro
      mctx.fillStyle = COLORS.treasure;
      mctx.fillRect(treasure.x * scaleX, treasure.y * scaleY, scaleX, scaleY);

      // jugador
      mctx.fillStyle = COLORS.player;
      mctx.beginPath();
      mctx.arc(
        player.x * scaleX + scaleX / 2,
        player.y * scaleY + scaleY / 2,
        Math.max(2, Math.min(scaleX, scaleY) / 3),
        0, Math.PI * 2
      );
      mctx.fill();
    }

    // Bucle
    let last = performance.now();
    function loop(now) {
      const dt = Math.min(0.05, (now - last) / 1000);
      last = now;
      shine += dt * 6;

      movePlayer();
      checkTreasure();
      updateCamera();
      drawScene();
      drawMinimap();

      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
