<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Joc del Tresor</title>
  <style>
    body { margin: 0; overflow: hidden; background: #222; color: #eee; font-family: system-ui, sans-serif; }
    #miniMap { position: absolute; top: 10px; right: 10px; border: 2px solid #fff; background: #111; }
    #status { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.6); padding: 8px 10px; border-radius: 6px; font-size: 14px; }
  </style>
</head>
<body>
  <div id="status">Usa las flechas para moverte</div>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <canvas id="miniMap" width="240" height="180"></canvas>

  <script>
    // Configuración general
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const miniMap = document.getElementById("miniMap");
    const miniCtx = miniMap.getContext("2d");

    const TILE = { GRASS: 0, TREE: 1, PATH: 2, RIVER: 3, ROCK: 4 };
    const tileSize = 32;
    const cols = 40;
    const rows = 30;
    const mapWidth = cols * tileSize;
    const mapHeight = rows * tileSize;

    // Mapa
    const map = Array.from({ length: rows }, () => Array(cols).fill(TILE.GRASS));

    // Generación de curvas (río y caminos)
    function generateCurve(yStart, thickness, wobble, type) {
      let cx = Math.floor(cols * 0.2 + Math.random() * cols * 0.6);
      for (let y = yStart; y < rows - 1; y++) {
        cx += Math.sin(y * 0.35 + wobble) * 0.6 + (Math.random() - 0.5) * 0.6;
        cx = Math.max(1, Math.min(cols - 2, cx));
        for (let t = -thickness; t <= thickness; t++) {
          const x = Math.floor(cx + t);
          if (x >= 0 && x < cols) map[y][x] = type;
        }
      }
    }

    // Río principal
    generateCurve(2, 2, Math.random() * 10, TILE.RIVER);
    // Caminos curvos (2 curvas más finas)
    generateCurve(0, 1, Math.random() * 10 + 5, TILE.PATH);
    generateCurve(0, 1, Math.random() * 10 + 15, TILE.PATH);

    // Distribución de árboles y rocas con clusters
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        if (map[y][x] === TILE.GRASS) {
          const r = Math.random();
          if (r < 0.12) map[y][x] = TILE.TREE;          // bosque denso
          else if (r < 0.16) map[y][x] = TILE.ROCK;     // rocas sueltas
        }
      }
    }
    // Añadir claros en los caminos
    for (let y = 0; y < rows; y++) for (let x = 0; x < cols; x++) {
      if (map[y][x] === TILE.PATH) { // limpia alrededor
        for (let oy = -1; oy <= 1; oy++) for (let ox = -1; ox <= 1; ox++) {
          const ny = y + oy, nx = x + ox;
          if (ny >= 0 && ny < rows && nx >= 0 && nx < cols && map[ny][nx] === TILE.TREE) {
            map[ny][nx] = TILE.GRASS;
          }
        }
      }
    }

    // Jugador y tesoro
    const player = { x: tileSize * 3, y: tileSize * 3, w: 26, h: 26, speed: 2.3 };
    const treasure = { x: 0, y: 0, w: 18, h: 18 };

    // Colisiones
    function tileAt(px, py) {
      const c = Math.floor(px / tileSize), r = Math.floor(py / tileSize);
      if (c < 0 || c >= cols || r < 0 || r >= rows) return TILE.ROCK; // borde bloquea
      return map[r][c];
    }
    function isBlocked(px, py) {
      const t = tileAt(px, py);
      return t === TILE.TREE || t === TILE.RIVER || t === TILE.ROCK;
    }

    // Movimiento con separación de ejes (para colisión suave)
    function move(dx, dy, dt) {
      const stepX = dx * player.speed * dt;
      const stepY = dy * player.speed * dt;
      // X
      const newX = player.x + stepX;
      const cx = newX + player.w / 2, cy = player.y + player.h / 2;
      if (!isBlocked(cx, cy) && !isBlocked(newX, player.y) && !isBlocked(newX + player.w, player.y + player.h)) {
        player.x = Math.max(0, Math.min(newX, mapWidth - player.w));
      }
      // Y
      const newY = player.y + stepY;
      const cx2 = player.x + player.w / 2, cy2 = newY + player.h / 2;
      if (!isBlocked(cx2, cy2) && !isBlocked(player.x, newY) && !isBlocked(player.x + player.w, newY + player.h)) {
        player.y = Math.max(0, Math.min(newY, mapHeight - player.h));
      }
    }

    // Colocar tesoro en lugar caminable aleatorio
    function placeTreasure() {
      for (let i = 0; i < 500; i++) {
        const cx = Math.floor(Math.random() * cols), cy = Math.floor(Math.random() * rows);
        if (map[cy][cx] === TILE.GRASS || map[cy][cx] === TILE.PATH) {
          treasure.x = cx * tileSize + (tileSize - treasure.w) / 2;
          treasure.y = cy * tileSize + (tileSize - treasure.h) / 2;
          return;
        }
      }
      treasure.x = tileSize * 10; treasure.y = tileSize * 10;
    }
    placeTreasure();

    // Dibujo de tiles con detalle
    function drawGrass(x, y, oX, oY) {
      // prado con variación
      const baseX = x * tileSize - oX, baseY = y * tileSize - oY;
      ctx.fillStyle = "#7fbf73";
      ctx.fillRect(baseX, baseY, tileSize, tileSize);
      ctx.strokeStyle = "rgba(255,255,255,0.05)";
      ctx.beginPath();
      ctx.moveTo(baseX + 4, baseY + 28);
      ctx.quadraticCurveTo(baseX + 12, baseY + 26, baseX + 20, baseY + 28);
      ctx.stroke();
    }
    function drawPath(x, y, oX, oY) {
      const bx = x * tileSize - oX, by = y * tileSize - oY;
      ctx.fillStyle = "#a37a53";
      ctx.fillRect(bx, by, tileSize, tileSize);
      // textura
      ctx.strokeStyle = "rgba(0,0,0,0.08)";
      for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.moveTo(bx + 4 + i * 9, by + 6);
        ctx.lineTo(bx + 6 + i * 9, by + 26);
        ctx.stroke();
      }
    }
    function drawRiver(x, y, oX, oY) {
      const bx = x * tileSize - oX, by = y * tileSize - oY;
      // agua
      const grad = ctx.createLinearGradient(bx, by, bx, by + tileSize);
      grad.addColorStop(0, "#3aa0ff");
      grad.addColorStop(1, "#1f78d1");
      ctx.fillStyle = grad;
      ctx.fillRect(bx, by, tileSize, tileSize);
      // orillas
      ctx.strokeStyle = "rgba(255,255,255,0.15)";
      ctx.beginPath();
      ctx.moveTo(bx + 2, by + 8); ctx.lineTo(bx + 30, by + 10);
      ctx.moveTo(bx + 3, by + 22); ctx.lineTo(bx + 29, by + 20);
      ctx.stroke();
    }
    function drawRock(x, y, oX, oY) {
      const bx = x * tileSize - oX, by = y * tileSize - oY;
      ctx.fillStyle = "#7d7d7d";
      ctx.beginPath();
      ctx.moveTo(bx + 8, by + 24);
      ctx.lineTo(bx + 14, by + 10);
      ctx.lineTo(bx + 24, by + 16);
      ctx.lineTo(bx + 22, by + 26);
      ctx.closePath();
      ctx.fill();
      // sombra
      ctx.fillStyle = "rgba(0,0,0,0.2)";
      ctx.fillRect(bx + 12, by + 18, 10, 6);
    }
    function drawTree(x, y, oX, oY) {
      const bx = x * tileSize - oX, by = y * tileSize - oY;
      // tronco
      ctx.fillStyle = "#6b4b2e";
      ctx.fillRect(bx + 12, by + 16, 8, 12);
      // copa
      ctx.fillStyle = "#2d7b2e";
      ctx.beginPath(); ctx.arc(bx + 10, by + 14, 10, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(bx + 20, by + 14, 10, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(bx + 15, by + 8, 12, 0, Math.PI * 2); ctx.fill();
      // brillo
      ctx.strokeStyle = "rgba(255,255,255,0.08)";
      ctx.beginPath(); ctx.arc(bx + 15, by + 8, 12, 0.2, 1.0); ctx.stroke();
    }

    function drawTile(x, y, oX, oY) {
      const t = map[y][x];
      if (t === TILE.GRASS) drawGrass(x, y, oX, oY);
      else if (t === TILE.PATH) drawPath(x, y, oX, oY);
      else if (t === TILE.RIVER) drawRiver(x, y, oX, oY);
      else if (t === TILE.ROCK) drawRock(x, y, oX, oY);
      else if (t === TILE.TREE) {
        // fondo hierba bajo árbol
        drawGrass(x, y, oX, oY);
        drawTree(x, y, oX, oY);
      }
    }

    // Dibujo del personaje con detalle (estilo aventurero)
    function drawPlayer(oX, oY) {
      const px = player.x - oX, py = player.y - oY;
      // botas
      ctx.fillStyle = "#5a3a1f";
      ctx.fillRect(px + 6, py + player.h - 6, 8, 6);
      ctx.fillRect(px + player.w - 14, py + player.h - 6, 8, 6);
      // cuerpo
      ctx.fillStyle = "#2e8b57";
      ctx.fillRect(px + 6, py + 8, player.w - 12, player.h - 12);
      // cinturón
      ctx.fillStyle = "#3a2a18";
      ctx.fillRect(px + 6, py + player.h - 16, player.w - 12, 4);
      // cabeza
      ctx.fillStyle = "#f1c27d";
      ctx.beginPath();
      ctx.arc(px + player.w / 2, py + 8, 8, 0, Math.PI * 2);
      ctx.fill();
      // ojos
      ctx.fillStyle = "#222";
      ctx.beginPath(); ctx.arc(px + player.w / 2 - 3, py + 6, 1.8, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(px + player.w / 2 + 3, py + 6, 1.8, 0, Math.PI * 2); ctx.fill();
      // gorro
      ctx.fillStyle = "#1f6f2f";
      ctx.beginPath();
      ctx.moveTo(px + player.w / 2 - 10, py + 2);
      ctx.quadraticCurveTo(px + player.w / 2 + 4, py - 6, px + player.w / 2 + 12, py + 4);
      ctx.lineTo(px + player.w / 2 - 8, py + 6);
      ctx.closePath(); ctx.fill();
      // escudo
      ctx.fillStyle = "#7f6a3a";
      ctx.beginPath(); ctx.arc(px + player.w - 4, py + 16, 7, -Math.PI / 2, Math.PI / 2); ctx.fill();
      ctx.strokeStyle = "#c9b37a"; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(px + player.w - 4, py + 16, 7, -Math.PI / 2, Math.PI / 2); ctx.stroke();
      // espada (brillo)
      ctx.strokeStyle = "#99d5ff"; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(px + 4, py + 14); ctx.lineTo(px - 6, py + 4); ctx.stroke();
      ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.moveTo(px + 4, py + 14); ctx.lineTo(px - 2, py + 8); ctx.stroke();
    }

    // Dibujo del tesoro (cofre)
    function drawTreasure(oX, oY) {
      const bx = treasure.x - oX, by = treasure.y - oY;
      // base
      ctx.fillStyle = "#b88a2a";
      ctx.fillRect(bx, by + 6, treasure.w, treasure.h - 6);
      // tapa
      ctx.fillStyle = "#9b6f1e";
      ctx.fillRect(bx, by, treasure.w, 8);
      // cerrojo
      ctx.fillStyle = "#333";
      ctx.fillRect(bx + treasure.w / 2 - 2, by + treasure.h / 2, 4, 6);
      ctx.fillStyle = "#e4c84a";
      ctx.fillRect(bx + treasure.w / 2 - 2, by + treasure.h / 2 - 2, 4, 2);
    }

    // Render del mapa
    function drawMap(oX, oY) {
      // Solo dibujar tiles visibles para rendimiento
      const startCol = Math.max(0, Math.floor(oX / tileSize));
      const startRow = Math.max(0, Math.floor(oY / tileSize));
      const endCol = Math.min(cols - 1, Math.floor((oX + canvas.width) / tileSize) + 1);
      const endRow = Math.min(rows - 1, Math.floor((oY + canvas.height) / tileSize) + 1);
      for (let y = startRow; y <= endRow; y++) {
        for (let x = startCol; x <= endCol; x++) {
          drawTile(x, y, oX, oY);
        }
      }
    }

    // Mini mapa
    function drawMiniMap() {
      miniCtx.clearRect(0, 0, miniMap.width, miniMap.height);
      const sX = miniMap.width / mapWidth, sY = miniMap.height / mapHeight;
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const t = map[y][x];
          let col;
          if (t === TILE.GRASS) col = "#7fbf73";
          else if (t === TILE.PATH) col = "#a37a53";
          else if (t === TILE.RIVER) col = "#2f8ae0";
          else if (t === TILE.ROCK) col = "#808080";
          else col = "#2d7b2e"; // árboles
          miniCtx.fillStyle = col;
          miniCtx.fillRect(x * tileSize * sX, y * tileSize * sY, tileSize * sX, tileSize * sY);
        }
      }
      // tesoro
      miniCtx.fillStyle = "gold";
      miniCtx.fillRect(treasure.x * sX, treasure.y * sY, Math.max(3, treasure.w * sX), Math.max(3, treasure.h * sY));
      // jugador
      miniCtx.fillStyle = "deepskyblue";
      miniCtx.fillRect(player.x * sX, player.y * sY, 6, 6);
    }

    // Bucle del juego
    let keys = new Set();
    let last = 0;
    function loop(ts) {
      const dt = Math.min(2, (ts - last) / 16.67); // normaliza a ~60fps, cap dt
      last = ts;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    function update(dt) {
      let dx = 0, dy = 0;
      if (keys.has("ArrowUp")) dy -= 1;
      if (keys.has("ArrowDown")) dy += 1;
      if (keys.has("ArrowLeft")) dx -= 1;
      if (keys.has("ArrowRight")) dx += 1;
      move(dx, dy, dt);

      // Tesoro recogido
      const overlapX = Math.abs((player.x + player.w / 2) - (treasure.x + treasure.w / 2)) < (player.w / 2);
      const overlapY = Math.abs((player.y + player.h / 2) - (treasure.y + treasure.h / 2)) < (player.h / 2);
      if (overlapX && overlapY) placeTreasure();
    }

    function draw() {
      const oX = player.x + player.w / 2 - canvas.width / 2;
      const oY = player.y + player.h / 2 - canvas.height / 2;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawMap(oX, oY);
      drawTreasure(oX, oY);
      drawPlayer(oX, oY);
      drawMiniMap();
    }

    // Controles
    document.addEventListener("keydown", (e) => {
      const arrows = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
      if (arrows.includes(e.key)) { e.preventDefault(); keys.add(e.key); }
    });
    document.addEventListener("keyup", (e) => keys.delete(e.key));

    // Iniciar
    requestAnimationFrame(loop);
  </script>
</body>
</html>
